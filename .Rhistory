#                                           PRELIMINARIES                                             #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
library(metafor)
library(dplyr)
library(testthat)
library(readxl)
library(stringr)
data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction"
code.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction/awr_data_extraction_git"
# location of original datasets and code for reproducible studies
original.data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Literature search/Full texts for review/*INCLUDED STUDIES"
setwd(code.dir); source("helper_extraction.R")
d = as.data.frame( matrix( ncol = 10, nrow = 0 ) )
names(d) = c( "authoryear",
"substudy",
"desired.direction",
"effect.measure",
"interpretation",
"use.rr.analysis",
"use.grams.analysis",
"use.veg.analysis",
"yi",
"vi")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                                  STEP 1 - MAIN-ANALYSIS STUDIES                                      #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# asterisks denote studies with raw data
##### **Amiot 2018 (PLOS) #####
# MM audited 2020-2-2
d = dplyr::add_row(.data = d,
authoryear = "Amiot 2018",
substudy = NA,
desired.direction = 1,
effect.measure = "log-rr",
interpretation = "Low vs. high 1-week consumption",
use.rr.analysis = 1,
use.grams.analysis = 0,
use.veg.analysis = 0,
yi = 0.395127,
vi = 5.670225e-02 )
##### **Anderson 2016 (PLOS), Study 3 ######
# MM audited 2020-2-2
# same study, 3 effect sizes for different analyses
d = dplyr::add_row(.data = d,
authoryear = "Anderson 2016",
substudy = NA,
desired.direction = 1,
effect.measure = "log-rr",
interpretation = "Low vs. high consumption",
use.rr.analysis = 1,
use.grams.analysis = 0,
use.veg.analysis = 0,
yi = 0.1092,
vi = 0.0060 )
library(metafor)
library(dplyr)
library(testthat)
library(readxl)
library(stringr)
data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction"
code.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction/awr_data_extraction_git"
# location of original datasets and code for reproducible studies
original.data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Literature search/Full texts for review/*INCLUDED STUDIES"
setwd(code.dir); source("helper_extraction.R")
d = as.data.frame( matrix( ncol = 10, nrow = 0 ) )
names(d) = c( "authoryear",
"substudy",
"desired.direction",
"effect.measure",
"interpretation",
"use.rr.analysis",
"use.grams.analysis",
"use.veg.analysis",
"yi",
"vi")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                                  STEP 1 - MAIN-ANALYSIS STUDIES                                      #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# asterisks denote studies with raw data
##### **Amiot 2018 (PLOS) #####
# MM audited 2020-2-2
d = dplyr::add_row(.data = d,
authoryear = "Amiot 2018",
substudy = NA,
desired.direction = 1,
effect.measure = "log-rr",
interpretation = "Low vs. high 1-week consumption",
use.rr.analysis = 1,
use.grams.analysis = 0,
use.veg.analysis = 0,
yi = 0.395127,
vi = 5.670225e-02 )
head(d)
mode(d$authoryear)
?checkpoint
getwd()
installed.packages()
# load packages
library(checkpoint)
# save the package environment that MBM used when analyzing
checkpoint("2020-02-12")
library(metafor)
library(dplyr)
library(testthat)
library(readxl)
library(stringr)
data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction"
code.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction/awr_data_extraction_git"
# location of original datasets and code for reproducible studies
original.data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Literature search/Full texts for review/*INCLUDED STUDIES"
setwd(code.dir); source("helper_extraction.R")
d = as.data.frame( matrix( ncol = 10, nrow = 0 ) )
names(d) = c( "authoryear",
"substudy",
"desired.direction",
"effect.measure",
"interpretation",
"use.rr.analysis",
"use.grams.analysis",
"use.veg.analysis",
"yi",
"vi")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
#                                  STEP 1 - MAIN-ANALYSIS STUDIES                                      #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# asterisks denote studies with raw data
##### **Amiot 2018 (PLOS) #####
# MM audited 2020-2-2
d = dplyr::add_row(.data = d,
authoryear = "Amiot 2018",
substudy = NA,
desired.direction = 1,
effect.measure = "log-rr",
interpretation = "Low vs. high 1-week consumption",
use.rr.analysis = 1,
use.grams.analysis = 0,
use.veg.analysis = 0,
yi = 0.395127,
vi = 5.670225e-02 )
citation(dplyr)
citation("dplyr")
# MM audited XXXX
data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction"
library(dplyr)
library(tidyverse)
library(readxl)
library(irr)
library(testthat)
setwd(data.dir)
setwd("Dual review of intervention components")
# read in each coder's dataset
# DR
dd = read.csv("component_coding_dr.csv")
dm = read_xlsx("component_coding_mm.xlsx")
dats = list(dd, dm)
# remove blank spacer rows
dats = lapply( dats, FUN = function(.d) .d = .d[ !is.na(.d$authoryear), ] )
expect_equal( unlist( lapply(dats, nrow) ), c(100, 100) )
# recode missing data
fake = d
table(fake$mind.attr)
fake = dd
table(fake$mind.attr)
fake = fake %>% replace_with_na_all( condition = ~.$x == "Unclear" )
library(tidyr)
fake = fake %>% replace_with_na_all( condition = ~.$x == "Unclear" )
library(naniar)
install.packages("naniar")
library(naniar)
fake = fake %>% replace_with_na_all( condition = ~.$x == "Unclear" )
dat_ms <- tibble::tribble(~x,  ~y,    ~z,
1,   "A",   -100,
3,   "N/A", -99,
NA,  NA,    -98,
-99, "E",   -101,
-98, "F",   -1)
head(dat_ms)
names(dat_ms) = c("A", "B", "C")
dat_ms
dat_ms
#replace all instances of -99 with NA
replace_with_na_all(data = dat_ms,
condition = ~.x == -99)
fake = fake %>% replace_with_na_all( condition = ~.x == "Unclear" )
table(fake$mind.attribution)
mean(fake$mind.attribution)
# recode missing data in all columns
dats = lapply( dats, FUN = function(.d) .d %>% replace_with_na_all( condition = ~.x == "Unclear" ) )
View(dats[[1]])
x = as.vector(dats[[1]])
str(x)
?mutate_all
names(dats[[1]])
rated.vars = c("mind.attribution", "social.norms", "id.victim", "impl.suggest", "pets")
fake = fake %>% mutate_at( rated.vars, as.numeric )
mean(fake$mind.attribution)
mean(fake$mind.attribution, na.rm = TRUE)
# cast the 0/1s as numeric
rated.vars = c("mind.attribution", "social.norms", "id.victim", "impl.suggest", "pets")
dats = lapply( dats, FUN = function(.d) .d %>% mutate_at( rated.vars, as.numeric ) )
# to do:
# - cite naniar package
############################### PREP RECONCILED SUBJECTIVE RISKS OF BIAS ###############################
# MM audited XXXX
data.dir = "~/Dropbox/Personal computer/Independent studies/2019/AWR (animal welfare review meat consumption)/Linked to OSF (AWR)/Data extraction"
library(dplyr)
library(tidyverse)
library(naniar)
library(tidyr)
library(readxl)
library(irr)
library(testthat)
setwd(data.dir)
setwd("Dual review of intervention components")
# read in each coder's dataset
dd = read.csv("component_coding_dr.csv")  # DR
dm = read_xlsx("component_coding_mm.xlsx")  # MBM
dats = list(dd, dm)
# remove blank spacer rows
dats = lapply( dats, FUN = function(.d) .d = .d[ !is.na(.d$authoryear), ] )
expect_equal( unlist( lapply(dats, nrow) ), c(100, 100) )
# recode missing data in all columns
dats = lapply( dats, FUN = function(.d) .d %>% replace_with_na_all( condition = ~.x == "Unclear" ) )
# there should not be any values except "0/1"
lapply( dats, FUN = function(.d) apply(.d, 2, table) )
# there should not be any values except "0/1"
lapply( dats, FUN = function(.d) apply(.d[,rating.vars], 2, table) )
# there should not be any values except "0/1"
lapply( dats, FUN = function(.d) apply(.d[,rated.vars], 2, table) )
# cast the 0/1s as numeric
dats = lapply( dats, FUN = function(.d) .d %>% mutate_at( rated.vars, as.numeric ) )
# for some reason, reads in years in an absurd format (e.g., "2018.0" as a string)
d3$Year = str_remove(d3$Year, "[.]0")
lapply( dats, FUN = function(.d) apply(.d[,rated.vars], 2, table) )
diff(dd, dm)
diff(dd[,rated.vars], dm[,rated.vars])
x1 = dats[[1]][,rated.vars]
x2 = dats[[2]][,rated.vars]
x1
x1*x2
str(x1*x2)
str(diff(x1,x2))
i=1
r1 = dats[[1]][i, rated.vars]
r2 = dats[[2]][i, rated.vars ]
r1
r2
diff(r1,r2)
diff( as.numeric(r1), as.numeric(r2) )
as.numeric(r1)
as.numeric(r2)
as.numeric(r1) - as.numeric(r2)
c(1,1,NA,1) - c(1,1,1,1)
x1 = c(1,1,NA,1)
x2 = c(1,1,1,1)
diffs = x1 - x2
diffs
diffs[ is.na(x1) | is.na(x2) ] = (is.na(x1) == is.na(x2))
diffs[ is.na(x1) | is.na(x2) ]
has.na = which( diffs[ is.na(x1) | is.na(x2) ] )
has.na = which( is.na(x1) | is.na(x2) )
has.na
is.na(x1[inds])
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
is.na(x1[inds])
diffs[inds] = ( is.na(x1[inds]) == is.na(x2[inds]) )
diffs
# test only
x1 = c(1,1,NA,1)
x2 = c(1,1,1,1)
diffs = x1 - x2
diffs
x1
x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
diffs[inds]
is.na(x1[inds])
is.na(x2[inds])
is.na(x1[inds]) == is.na(x2[inds])
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree
x1 = c(1,1,NA,1,NA)
x2 = c(1,1,1,1,NA)
diffs = x1 - x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree
nas.disagree[ nas.disagree == TRUE ] = -1
nas.disagree
nas.disagree[ nas.disagree == FALSE ] = 0
diffs[inds] = nas.disagree
diffs
# test only
x1 = c(1,1,NA,1,NA)
x2 = c(1,0,1,1,NA)
diffs = x1 - x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree[ nas.disagree == TRUE ] = -1
nas.disagree[ nas.disagree == FALSE ] = 0
diffs[inds] = nas.disagree
diffs
my_diff_NA = function(x1, x2){
# test only
x1 = c(1,1,NA,1,NA)
x2 = c(1,0,1,1,NA)
diffs = x1 - x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree[ nas.disagree == TRUE ] = -1
nas.disagree[ nas.disagree == FALSE ] = 0
diffs[inds] = nas.disagree
}
my_diff_NA = function(x1, x2){
# # test only
# x1 = c(1,1,NA,1,NA)
# x2 = c(1,0,1,1,NA)
diffs = x1 - x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree[ nas.disagree == TRUE ] = -1
nas.disagree[ nas.disagree == FALSE ] = 0
diffs[inds] = nas.disagree
}
diffsMat = dats[[1]] %>% replace_with_na_all( condition = TRUE )
x = dats[[1]]
x = NA
x
x = dats[[1]]
x[]=NA
x
# initialize empty dataframe with same headers
diffs = dats[[1]]
diffs[] = NA
diffs
i=3
my_diff_NA( dats[[1]][i,], dats[[2]][i,] )
dats[[1]][i,]
diffs = dats[[1]]
diffs[ , c(rated.vars, notes) ] = NA
# initialize empty dataframe with same headers
diffs = dats[[1]]
diffs[ , c(rated.vars, "notes") ] = NA
View(diffs)
my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
my_diff_NA = function(x1, x2){
# # test only
# x1 = c(1,1,NA,1,NA)
# x2 = c(1,0,1,1,NA)
diffs = x1 - x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree[ nas.disagree == TRUE ] = -1
nas.disagree[ nas.disagree == FALSE ] = 0
diffs[inds] = nas.disagree
return(diffs)
}
my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
my_diff_NA( dats[[1]][i, rated.vars]
)
dats[[1]][i, rated.vars]
dats[[2]][i, rated.vars ]
diffs[i,]
diffs = dats[[1]]
diffs[ , c(rated.vars, "notes") ] = NA
for( i in 1:nrow(dats[[1]]) ){
diffs[ i, rated.vars ] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
diffs
# initialize empty dataframe with same headers
diffs = dats[[1]]
diffs[ , c(rated.vars, "notes") ] = NA
for( i in 1:nrow(dats[[1]]) ){
diffs[ i, rated.vars ] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
i
my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
mode(diffs[,1])
diffs = dats[[1]]
diffs[ , c(rated.vars, "notes") ] = NA
diffs = diffs %>% mutate_at( rated.vars, as.numeric )
for( i in 1:nrow(dats[[1]]) ){
diffs[ i, rated.vars ] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
i
my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
diffs
View(diffs)
diffs[ i, rated.vars ]
diffs[ i, rated.vars ] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
x = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
mode(x)
x
as.numeric(x)
my_diff_NA = function(x1, x2){
# # test only
# x1 = c(1,1,NA,1,NA)
# x2 = c(1,0,1,1,NA)
diffs = x1 - x2
# entries for which either x1 or x2 is NA
inds = which( is.na(x1) | is.na(x2) )
# when one coder has NA and the other doesn't, should be coded as
#  a discrepancy, but use -1 to differentiate from a 0 vs. 1 discrepancy
nas.disagree = ( is.na(x1[inds]) != is.na(x2[inds]) )
nas.disagree[ nas.disagree == TRUE ] = -1
nas.disagree[ nas.disagree == FALSE ] = 0
diffs[inds] = nas.disagree
return( as.numeric(diffs) )
}
# initialize empty dataframe with same headers
diffs = dats[[1]]
diffs[ , c(rated.vars, "notes") ] = NA
diffs = diffs %>% mutate_at( rated.vars, as.numeric )
for( i in 1:nrow(dats[[1]]) ){
diffs[ i, rated.vars ] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
i
i=1
diffs = as.data.frame( as.my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ) )
diffs = as.data.frame( my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ) )
diffs
diffs = as.matrix( my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ),
nrow = 1 )
diffs
?as.matrix
my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
as.matrix( my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ),
nrow = 1 )
matrix( my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ),
nrow = 1 )
diffs = NULL
i=1
if ( i == 1 ){
diffs = matrix( my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ),
nrow = 1 )
} else {
diffs[i,] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
diffs
i=2
if ( i == 1 ){
diffs = matrix( my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] ),
nrow = 1 )
} else {
diffs[i,] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
diffs = matrix( NA, nrow = nrow(dats[[1]]), ncol = ncol(dats[[1]]) )
diffs
diffs[i,] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
diffs[i,]
diffs = matrix( NA, nrow = nrow(dats[[1]]), ncol = length(rating.vars) )
diffs[i,] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
dim(diffs)
rating.vars
diffs = matrix( NA, nrow = nrow(dats[[1]]), ncol = length(rated.vars) )
diffs[i,] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
diffs
diffs = matrix( NA, nrow = nrow(dats[[1]]), ncol = length(rated.vars) )
for( i in 1:nrow(diffs) ){
diffs[i,] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
#diffs[ i, rated.vars ] = my_diff_NA( dats[[1]][i, rated.vars], dats[[2]][i, rated.vars ] )
}
diffs
names(d)
names(dats[[1]])
as.data.frame( diffs, row.names = rated.vars )
?as.data.frame
# put back the other columns
diffs2 = cbind( data.frame( authoryear = dats[[1]]$authoryear,
unique = dats[[1]]$unique ),
as.data.frame( diffs, col.names = rated.vars )
)
as.data.frame( diffs, col.names = rated.vars )
rated.vars
as.data.frame( diffs, col.names = rated.vars )
diffs2 = cbind( data.frame( authoryear = dats[[1]]$authoryear,
unique = dats[[1]]$unique ),
as.data.frame( diffs, col.names = rated.vars ),
data.frame( notesDR = dats[[1]]$notes,
notesMBM = dats[[2]]$notes ) )
head(diffs2)
names( diffs2 )[2:8]
names( diffs2 )[3:7]
names( diffs2 )[3:7] = rated.vars
View(diffs2)
View(dats[[1]])
setwd(data.dir)
list.files()
setwd("Dual review of intervention components")
list.files()
write.csv(diffs2, "interrater_discrepancies.csv")
write.csv(dats[[1]], "component_coding_dr_prepped.csv")
write.csv(dats[[2]], "component_coding_mm_prepped.csv")
